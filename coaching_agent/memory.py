"""
Customer Memory — session context + persistent preferences.

Two tiers:
  - SessionMemory:    in-memory, single conversation (cleared on session end)
  - CustomerMemory:   persistent goals, preferences, past summaries
                      (persisted to JSON in data/customer_store/;
                       in production: replace with Cosmos DB / Redis)

Epic 2.4 additions:
  - GoalRecord:            typed goal with progress tracking
  - CustomerPreferences:   channel, tone, topic preferences
  - JSON persistence:      load_customer_store / save_customer_store
  - Session summaries:     2-3 sentence summaries persist between sessions
"""

from __future__ import annotations

import json
import os
from dataclasses import asdict, dataclass, field
from datetime import date, datetime
from typing import Any


# ---------------------------------------------------------------------------
# Sub-models
# ---------------------------------------------------------------------------

@dataclass
class GoalRecord:
    """A financial goal set by the customer during coaching."""
    goal_id: str
    description: str
    target_amount: float | None
    target_date: str | None       # ISO date string "YYYY-MM-DD" (JSON-serialisable)
    created_at: str = field(default_factory=lambda: datetime.utcnow().isoformat())
    status: str = "active"        # active | achieved | cancelled
    progress_notes: list[str] = field(default_factory=list)


@dataclass
class CustomerPreferences:
    """Learned communication preferences — updated as conversations progress."""
    preferred_tone: str = "balanced"          # concise | detailed | balanced
    prefers_examples: bool = True
    preferred_topics: list[str] = field(default_factory=list)   # e.g. ["savings", "mortgage"]
    opted_in_nudges: bool = True
    last_updated: str = field(default_factory=lambda: datetime.utcnow().isoformat())


@dataclass
class SessionSummary:
    """Compressed record of a past coaching session — injected into future system prompts."""
    session_id: str
    date: str                     # ISO date string
    summary: str                  # 2-3 sentences generated by LLM at session end
    topics_covered: list[str] = field(default_factory=list)
    goals_set: list[str] = field(default_factory=list)


# ---------------------------------------------------------------------------
# CustomerMemory — persistent, cross-session
# ---------------------------------------------------------------------------

@dataclass
class CustomerMemory:
    """
    Persistent customer context — survives between sessions.
    Loaded from / saved to data/customer_store/<customer_id>.json.
    In production: replace JSON with Cosmos DB / Redis.
    """
    customer_id: str
    name: str
    goals: list[GoalRecord] = field(default_factory=list)
    preferences: CustomerPreferences = field(default_factory=CustomerPreferences)
    last_health_score: int | None = None
    last_health_score_date: str | None = None
    previous_sessions: list[SessionSummary] = field(default_factory=list)
    conversation_count: int = 0

    # Legacy field kept for backward compatibility
    previous_insights_summary: str | None = None

    @property
    def active_goals(self) -> list[GoalRecord]:
        return [g for g in self.goals if g.status == "active"]

    def add_goal(
        self,
        description: str,
        target_amount: float | None = None,
        target_date: str | None = None,
    ) -> GoalRecord:
        goal = GoalRecord(
            goal_id=f"GOAL_{len(self.goals) + 1:03d}",
            description=description,
            target_amount=target_amount,
            target_date=target_date,
        )
        self.goals.append(goal)
        return goal

    def _find_similar_goal(self, description: str) -> "GoalRecord | None":
        """
        Return an existing active goal whose topic overlaps significantly
        with `description`. Uses keyword intersection — no LLM required.

        Overlap threshold: >= 2 meaningful shared words, OR one of a set of
        known topic keywords matches exactly (house, deposit, emergency, holiday,
        car, debt, retirement, wedding, mortgage, savings).
        """
        TOPIC_KEYWORDS = {
            "house", "deposit", "emergency", "fund", "holiday", "car",
            "debt", "retirement", "wedding", "mortgage", "savings",
            "nursery", "childcare", "baby", "pension", "travel",
        }

        def _tokens(text: str) -> set[str]:
            # Lower-case words, strip punctuation, drop short stop-words
            import re
            words = re.findall(r"[a-z]+", text.lower())
            stop = {"i", "a", "to", "for", "my", "the", "and", "or",
                    "want", "would", "like", "save", "saving", "get",
                    "by", "end", "of", "in", "up", "build", "pay", "off"}
            return {w for w in words if w not in stop}

        new_tokens = _tokens(description)
        new_topics = new_tokens & TOPIC_KEYWORDS

        for goal in self.active_goals:
            existing_tokens = _tokens(goal.description)
            existing_topics = existing_tokens & TOPIC_KEYWORDS

            # Topic keyword match (strongest signal)
            if new_topics & existing_topics:
                return goal

            # General token overlap fallback (>= 2 shared meaningful words)
            if len(new_tokens & existing_tokens) >= 2:
                return goal

        return None

    def add_or_update_goal(
        self,
        description: str,
        target_amount: float | None = None,
        target_date: str | None = None,
    ) -> tuple["GoalRecord", bool]:
        """
        Upsert a goal:
        - If a similar active goal already exists → update it with the
          new (more specific) description/amount/date and return (goal, False).
        - Otherwise → create a new goal and return (goal, True).

        Returns (goal, was_created).
        """
        existing = self._find_similar_goal(description)
        if existing:
            # Always take the longer / more specific description
            if len(description) > len(existing.description):
                existing.description = description
            if target_amount is not None:
                existing.target_amount = target_amount
            if target_date is not None:
                existing.target_date = target_date
            return existing, False

        goal = self.add_goal(description, target_amount, target_date)
        return goal, True

    def update_health_score(self, score: int) -> None:
        self.last_health_score = score
        self.last_health_score_date = date.today().isoformat()

    def add_session_summary(self, summary: SessionSummary) -> None:
        """Keep the last 5 session summaries to control token usage."""
        self.previous_sessions.append(summary)
        self.previous_sessions = self.previous_sessions[-5:]
        self.conversation_count += 1


# ---------------------------------------------------------------------------
# SessionMemory — in-memory, single conversation
# ---------------------------------------------------------------------------

@dataclass
class SessionMemory:
    """
    Per-conversation context — cleared at session end.
    Holds the current conversation history and loaded data.
    """
    session_id: str
    customer_id: str
    messages: list[dict[str, str]] = field(default_factory=list)
    loaded_insights: dict[str, Any] | None = None
    grounded_amounts: set[str] = field(default_factory=set)
    tool_calls_made: list[str] = field(default_factory=list)

    def add_message(self, role: str, content: str) -> None:
        self.messages.append({"role": role, "content": content})

    def get_history(self) -> list[dict[str, str]]:
        """Return conversation history for LLM context window."""
        return self.messages[-10:]  # Last 10 turns to control token usage

    def register_tool_call(self, tool_name: str) -> None:
        self.tool_calls_made.append(tool_name)


# ---------------------------------------------------------------------------
# JSON persistence helpers
# ---------------------------------------------------------------------------

_STORE_DIR = os.path.join(
    os.path.dirname(__file__), "..", "data", "customer_store"
)


def _store_path(customer_id: str) -> str:
    return os.path.join(_STORE_DIR, f"{customer_id}.json")


def _ensure_store_dir() -> None:
    os.makedirs(_STORE_DIR, exist_ok=True)


def _serialise_customer(mem: CustomerMemory) -> dict:
    """Convert CustomerMemory to a plain JSON-serialisable dict."""
    return {
        "customer_id": mem.customer_id,
        "name": mem.name,
        "goals": [asdict(g) for g in mem.goals],
        "preferences": asdict(mem.preferences),
        "last_health_score": mem.last_health_score,
        "last_health_score_date": mem.last_health_score_date,
        "previous_sessions": [asdict(s) for s in mem.previous_sessions],
        "conversation_count": mem.conversation_count,
        "previous_insights_summary": mem.previous_insights_summary,
    }


def _deserialise_customer(data: dict) -> CustomerMemory:
    """Reconstruct CustomerMemory from a JSON dict."""
    goals = [GoalRecord(**g) for g in data.get("goals", [])]
    prefs_data = data.get("preferences", {})
    if prefs_data:
        preferences = CustomerPreferences(**prefs_data)
    else:
        preferences = CustomerPreferences()
    sessions = [SessionSummary(**s) for s in data.get("previous_sessions", [])]
    return CustomerMemory(
        customer_id=data["customer_id"],
        name=data["name"],
        goals=goals,
        preferences=preferences,
        last_health_score=data.get("last_health_score"),
        last_health_score_date=data.get("last_health_score_date"),
        previous_sessions=sessions,
        conversation_count=data.get("conversation_count", 0),
        previous_insights_summary=data.get("previous_insights_summary"),
    )


def load_customer_store(customer_id: str, name: str) -> CustomerMemory:
    """
    Load CustomerMemory from JSON file. Creates a fresh record if none exists.
    Falls back to in-memory store if file I/O fails (never breaks the agent).
    """
    _ensure_store_dir()
    path = _store_path(customer_id)
    if os.path.exists(path):
        try:
            with open(path, "r", encoding="utf-8") as f:
                data = json.load(f)
            return _deserialise_customer(data)
        except Exception as e:
            print(f"[MEMORY] Failed to load store for {customer_id}: {e} — using fresh record")
    return CustomerMemory(customer_id=customer_id, name=name)


def save_customer_store(mem: CustomerMemory) -> None:
    """
    Persist CustomerMemory to JSON. Fails silently — never breaks the agent.
    """
    _ensure_store_dir()
    path = _store_path(mem.customer_id)
    try:
        with open(path, "w", encoding="utf-8") as f:
            json.dump(_serialise_customer(mem), f, indent=2)
    except Exception as e:
        print(f"[MEMORY] Failed to save store for {mem.customer_id}: {e}")


# ---------------------------------------------------------------------------
# In-memory session store (not persisted — lives only for the duration of process)
# ---------------------------------------------------------------------------

_session_store: dict[str, SessionMemory] = {}


def get_or_create_customer(customer_id: str, name: str) -> CustomerMemory:
    """Load from JSON store (or create fresh) — replaces old in-memory dict."""
    return load_customer_store(customer_id, name)


def create_session(session_id: str, customer_id: str) -> SessionMemory:
    session = SessionMemory(session_id=session_id, customer_id=customer_id)
    _session_store[session_id] = session
    return session


def get_session(session_id: str) -> SessionMemory | None:
    return _session_store.get(session_id)
